#' 
#' @title Generates 2-dimensional contingency tables
#' @description The function ds.table2d is a client-side wrapper function. It calls the server-side 
#' subfunction table2dDS to generate 2-dimensional tables for all data sources. 
#' @details Valid (non-disclosive) data are defined as data from sources where no table cells have 
#' counts between 1 and 4 (the upper value [4] can in principle be changed but only by rewriting the 
#' underlying function - it cannot be changed by a standard DataSHIELD user). If the count in any cell
#' in the table produced by a given data source IS invalid, that cell count is changed to "-1" and the 
#' name of the two categories that correspond to it are both changed to "-9". Each source is flagged 
#' as having only valid data, or at least some invalid data. The function ds.table2d prints out counts, 
#' column percents, row percents, global percents and a chi-squared test for homogeneity on (nc-1)*(nr-1) 
#' degrees of freedom where nc is the number of columns and nr is the number of rows. These calaculations 
#' are done separately for each source and, in addition, all valid sources are combined to produce a 
#' single overarching contingency for all valid data collectively. Missing data are treated as 
#' na.action=na.omit (default for table function), if missing data are to be treated as a separate 
#' and visible category, the variable should first be transformed to convert NAs to the a new value.
#' @param datasources a list of opal object(s) obtained after login in to opal servers; 
#' these objects hold also the data assign to R, as \code{dataframe}, from opal datasources. 
#' @param x a numerical vector with discrete values - usually a factor
#' @param y a numerical vector with discrete values - usually a factor
#' @param type a character which represent the type of graph to display
#' If \code{type} is set to 'combine', a histogram that merges the single 
#' plot is displayed. Each histogram is plotted separately if If \code{type} 
#' is set to 'split'.
#' @return A list object containing the following items (depending on the type of analysis specified -
#' 'combined' or 'split- some of these items may not be returned): 
#' \item{OPALS.DATA.OVERVIEW}{For each study contains $study.name (ie name of study), $is.table.valid 
#' (TRUE if all cells valid otherwise FALSE), $safe.table (the safe contingency table that contains 
#' all cells if all are valid, but otherwise obscures invalid cells by outputting a cell count of "-1" and
#' making the two category indicators for that cell = "-9". In other words OPALS.DATA.OVERVIEW provides the 
#' information generated by the server side subfunction table2dDS on its own.}
#' \item{ALL.VALID.TABLES.BY.STUDY}{Counts, column percents, row percents and global percents for each study
#' separately (if separate.and.combined.studies=TRUE) and for all valid studies combined}
#' \item{CHI2.TESTS.FOR.HOMOGENEITY}{Chi-squared test for homogeneity, for each study
#' separately (if separate.and.combined.studies=TRUE) and for all valid studies combined}
#' \item{VALIDITY.WARNING - IF NEEDED}{Either reports that all studies are valid, or else lists the studies that
#' contain at least one cell that is invalid, or else reports "NO STUDIES HAVE VALID DATA - SO NO ATTEMPT TO COMBINE"}
#' \item{TABLES.VALID.DATA.COUNTS}{If all.output.configurations=TRUE, cell counts, for each study
#' separately and for all valid studies combined}
#' \item{TABLES.VALID.DATA.COLUMN.PERCENTS}{If all.output.configurations=TRUE, column percents, for each study
#' separately and for all valid studies combined}
#' \item{TABLES.VALID.DATA.ROW.PERCENTS}{If all.output.configurations=TRUE, row percents, for each study
#' separately and for all valid studies combined}
#' \item{TABLES.VALID.DATA.GLOBAL.PERCENTS}{If all.output.configurations=TRUE, global percents, for each study
#' separately and for all valid studies combined}
#' @author Burton P.; Gaye, A.
#' @export
#' @examples 
#' {
#' 
#' # load the file that contains the login details
#' data(logindata)
#' 
#' # login and assign the required variables to R
#' myvar  <-  list('DIS_DIAB', 'DIS_CVA', 'GENDER', 'LAB_HDL')
#' opals  <-  datashield.login(logins=logindata,assign=TRUE,variables=myvar)
#' 
#' # Example 1: generate a two dimensional table, outputting combined contingency tables - default behaviour
#' ds.table2D(x='D$DIS_DIAB', y='D$GENDER')
#' 
#' # Example 2: generate a two dimensional table, outputting study specific contingency tables
#' ds.table2D(x='D$DIS_DIAB', y='D$GENDER', type='split')
#' 
#' # Example 3: generate a two dimensional table, outputting combined contingency tables 
#' # (in this case some studies are invalid)
#' ds.table2D(x='D$DIS_CVA', y='D$GENDER')
#' 
#' # Example 4: generate a two dimensional table, outputting study specific contingency tables 
#' # (in this case some studies are invalid)
#' ds.table2D(x='D$DIS_CVA', y='D$GENDER', type='split')

#' # Example 6: generate a two dimensional table, outputting study specific and combined contingency tables, 
#' # see what happens if you try to tabulate a quantitative variable with unique values for many individuals. 
#' # The standard table() function in R would print out all observed 'values' as category names in ascending 
#' # order with a count (generally 1) for each unique number, but ds.table2d prints out all values where 
#' # there are between 1 and 4 observations as -1 and gives the category name -9. It is only when the count is 
#' # 5 or more that the actual value can be observed, and then it is non-disclosive.
#' ds.table2D(x ='D$GENDER', y='D$LAB_HDL')
#' ds.table2D(x ='D$GENDER', y='D$LAB_HDL', type='split')
#' 
#' # clear the Datashield R sessions and logout
#' datashield.logout(opals)
#' 
#' }
#' 
ds.table2D <- function(x=NULL, y=NULL, type='combine', datasources=NULL){ 

  # if no opal login details were provided look for 'opal' objects in the environment
  if(is.null(datasources)){
    findLogin <- getOpals()
    if(findLogin$flag == 1){
      datasources <- findLogin$opals
    }else{
      if(findLogin$flag == 0){
        stop(" Are yout logged in to any server? Please provide a valid opal login object! ", call.=FALSE)
      }else{
        message(paste0("More than one list of opal login object were found: '", paste(findLogin$opals,collapse="', '"), "'!"))
        userInput <- readline("Please enter the name of the login object you want to use: ")
        datasources <- eval(parse(text=userInput))
        if(class(datasources[[1]]) != 'opal'){
          stop("End of process: you failed to enter a valid login object", call.=FALSE)
        }
      }
    }
  }
  
  if(is.null(x)){
    stop("Please provide the name of the numeric vector 'x'!", call.=FALSE)
  }
  
  if(is.null(y)){
    stop("Please provide the name of the numeric vector 'y'!", call.=FALSE)
  }
  
  # the input variable might be given as column table (i.e. D$object)
  # or just as a vector not attached to a table (i.e. object)
  # we have to make sure the function deals with each case
  objects <- c(x, y)
  xnames <- extract(objects)
  varnames <- xnames$elements
  obj2lookfor <- xnames$holders
  var.name.1 <- varnames[1]
  var.name.2 <- varnames[2]
  
  # check if the input object(s) is(are) defined in all the studies
  for(i in 1:length(varnames)){
    if(is.na(obj2lookfor[i])){
      defined <- isDefined(datasources, varnames[i])
    }else{
      defined <- isDefined(datasources, obj2lookfor[i])
    }
  }
  
  # call the internal function that checks the input object(s) is(are) of the same class in all studies.
  for(i in 1:length(objects)){
    typ <- checkClass(datasources, objects[i])
  }
  
  # names of the studies 
  opals.names <- names(datasources)
  
  # number of studies to analyse
  numsources <- length(datasources)
  
 # call the server side function that produces a 2-dimensional table for each study
  cally <- paste0("table2dDS(", x, ",", y, ")")
  server.func.output <- datashield.aggregate(datasources, as.symbol(cally))  

  # call the 1st helper script to carry out validity checks on the study specific tables
  # returned by the 'table2dDS'
  helper1out <- table2dhelper1(server.func.output, var.name.1, var.name.2)
  zero.studies.valid <- helper1out$zero.studies.valid
  num.valid.studies <- helper1out$num.valid.tables
  opals.valid.id <- helper1out$opals.valid.id
  
  # call the 4th helper script to generate the final output
  # this function calls the helper 1, 2 and 3 functions that
  # generate all the key elements required to produce the final output
  helper4out <- table2dhelper4(server.func.output, var.name.1, var.name.2)
  
  # return the right output depending what the user specified: 'combine' or 'split' analysis
  if(type=="combine"){
    # if the user specifies 'combined' analysis we output all the combines outputs but NOT the study specific outputs
    if(zero.studies.valid){
      output1 <- helper4out$VALIDITY.WARNING
      return(list("VALIDITY.WARNING"=output1))
    }else{
      output1 <- helper4out$TABLES.VALID.DATA.COUNTS
      output2 <- helper4out$TABLES.VALID.DATA.COLUMN.PERCENTS
      output3 <- helper4out$TABLES.VALID.DATA.ROW.PERCENTS
      output4 <- helper4out$TABLES.VALID.DATA.GLOBAL.PERCENTS
      output5 <- helper4out$CHI2.TESTS.FOR.HOMOGENEITY
      output6 <- helper4out$VALIDITY.WARNING
      
      # combined ouput is returned only if all the studies are valid
      outnames <- c(paste("COMBINED.VALID.DATA.COUNTS--",var.name.1," (rows) V ",var.name.2," (cols) ",sep=""),
                    paste("COMBINED.VALID.DATA.COLUMN.PERCENTS--",var.name.1," (rows) V ",var.name.2," (cols) ",sep=""),
                    paste("COMBINED.VALID.DATA.ROW.PERCENTS--",var.name.1," (rows) V ",var.name.2," (cols) ",sep=""),
                    paste("COMBINED.VALID.DATA.GLOBAL.PERCENTS--",var.name.1," (rows) V ",var.name.2," (cols) ",sep=""),
                    "CHI2.TESTS.FOR.HOMOGENEITY","VALIDITY.WARNING")    
      if(num.valid.studies==numsources){
        obj2return <- list(output1[,,numsources+1],output2[,,numsources+1],output3[,,numsources+1],
                           output4[,,numsources+1],output5,output6)
        
        names(obj2return) <- outnames
        return(obj2return)  
      }else{
        output1 <- helper4out$TABLES.VALID.DATA.COUNTS[,,num.valid.studies+1]
        output2 <- helper4out$TABLES.VALID.DATA.COLUMN.PERCENTS[,,num.valid.studies+1]
        output3 <- helper4out$TABLES.VALID.DATA.ROW.PERCENTS[,,num.valid.studies+1]
        output4 <- helper4out$TABLES.VALID.DATA.GLOBAL.PERCENTS[,,num.valid.studies+1]
        obj2return <- list(output1,output2,output3,output4,output5,output6)
        names(obj2return) <- outnames        
        return(obj2return)  
      }
    }
  }else{
     # if the user specifies 'split' analysis we output all the study specific outputs but NOT the combines outputs
    if(type=="split"){
      
      output1 <- helper4out$OPALS.DATA.OVERVIEW
      output2 <- helper4out$ALL.VALID.TABLES.BY.STUDY[,,,1:num.valid.studies]
      output3 <- helper4out$VALIDITY.WARNING  
      output4 <- helper4out$CHI2.TESTS.FOR.HOMOGENEITY
      
      if(zero.studies.valid){
        warning("NO STUDIES HAVE VALID DATA FOR '", var.name.1, "' OR '", var.name.2, "'", immediate.=TRUE, call.=FALSE)
        warning("NO ATTEMPT TO TABULATE INDIVIDUAL STUDIES", immediate.=TRUE, call.=FALSE)
      }else{
        if(num.valid.studies==numsources){
          return(list("OPALS.DATA.OVERVIEW"=output1, "ALL.VALID.TABLES.BY.STUDY"=output2, "VALIDITY.WARNING"=output3,
                      "CHI2.TESTS.FOR.HOMOGENEITY"=output4))
        }else{
          # amend the 'dimnames' to include only study names since we exclude 'combined' result in the line above
          dnames <- dimnames(output2)
          valid.studies.names <- opals.names[which(opals.valid.id==1)]
          for(i in 1:num.valid.studies){
            for(j in 1:4){
              dnames[3][[1]][j] <- paste(dnames[3][[1]][j], "--",valid.studies.names[i], sep="")
            }
          }
          dimnames(output2) <- dnames
          return(list("OPALS.DATA.OVERVIEW"=output1, "ALL.VALID.TABLES.BY.STUDY"=output2, "VALIDITY.WARNING"=output3,
                      "CHI2.TESTS.FOR.HOMOGENEITY"=output4))
        }
      }
    }else{
      stop('Function argument "type" has to be either "combine" or "split"')
    }
  }
} 

