% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.glmerSLMA.R
\name{ds.glmerSLMA}
\alias{ds.glmerSLMA}
\title{Fitting generalized linear mixed effect models in the server-side}
\usage{
ds.glmerSLMA(
  formula = NULL,
  offset = NULL,
  weights = NULL,
  combine.with.metafor = TRUE,
  dataName = NULL,
  checks = FALSE,
  datasources = NULL,
  family = NULL,
  control_type = NULL,
  control_value = NULL,
  verbose = 0,
  start_theta = NULL,
  start_fixef = NULL,
  notify.of.progress = FALSE
)
}
\arguments{
\item{formula}{Denotes an R object of class formula which is a character string which describes
the model to be fitted. Most shortcut notation allowed by lme4's glmer() function is
also allowed by ds.glmerSLMA. Many glmes can be fitted very simply using a formula like:
"y~a+b+(1|c)" which simply means fit a glme with y as the outcome variable (e.g. 
a binary case-control using a logistic regression model or a count or a survival
time using a Poisson regression model) with a and b
as fixed effects, and c as a random effect or grouping factor. This allows for a random
intercept between groups which allows, for example, the analysis of, or correction for,
correlated outcomes between observational units in a group. It is also possible to fit models
with random slopes by specifying a model such as "y~a+b+(1+b|c)" where the effect of
b can vary randomly between groups defined by c.
Implicit nesting can be specified with formulae such as "y~a+b+(1|c/d)"
or "y~a+b+(1|c)+(1|c:d)". See the following for more details:
https://cran.r-project.org/web/packages/lme4/vignettes/lmer.pdf}

\item{offset}{A character string specifying the name of a variable to be used as
an offset (effectively a component of the linear predictor of the glme which has a known
coefficient a-priori and so does not need to be estimated by the model). When using a
Poisson  model to fit outcome data consisting of a survival time and a censoring
variable (1=died, 0=alive) - e.g. when using what is called
'piecewise exponential regression' - the natural log of the survival time is
often used as an offset.}

\item{weights}{A character string specifying the name of a variable containing
prior regression weights for the fitting process.}

\item{combine.with.metafor}{This argument is Boolean. If TRUE (the default) the
estimates and standard errors for each regression coefficient are pooled across
studies using random effects meta-analysis under maximum likelihood (ML),
restricted maximum likelihood (REML), or fixed effects meta-analysis (FE).}

\item{dataName}{A character string specifying the name of an (optional) dataframe
that contains all of the variables in the lme formula. This avoids you having
to specify the name of the dataframe in front of each covariate in the formula
e.g. if the dataframe is called 'DataFrame' you avoid having to write: 
"DataFrame$y~DataFrame$a+DataFrame$b+(1|DataFrame$c)" where
processing stops if a non existing data frame is indicated (e.g. if you misspell the name).
If no dataName is specified
or it is specified as NULL, each variable in the formula must either sit in the top
level folder in the search path (ie where new objects are being placed by default)
or else you must explicitly specify the dataframe in which other variables sit.
e.g.  formula = "DataFrame1$y~DataFrame2$a+b+(1|DataFrame2$c)" if variable y is
in DataFrame1, variable a and c are in DataFrame2 and b is in the top level folder.}

\item{checks}{This argument is Boolean. If TRUE ds.glmerSLMA undertakes a series
of preliminary checks of structural integrity of the model. Specifically
it verifies that the variables in the model are all defined (exist) on the server site
at every study and that they have the correct characteristics (e.g. class) required to fit
the model. The argument defaults to FALSE because the checks markedly increase
the time taken to apply the function and so it is suggested that it is only made TRUE
if an unexplained problem in the model fit is encountered.}

\item{datasources}{specifies the particular opal object(s) to use. If the <datasources>
argument is not specified the default set of opals will be used. The default opals
are called default.opals and the default can be set using the function
{ds.setDefaultOpals.o}. If the <datasources> is to be specified, it should be set without
inverted commas: e.g. datasources=opals.em or datasources=default.opals. If you wish to
apply the function solely to e.g. the second opal server in a set of three,
the argument can be specified as: e.g. datasources=opals.em[2].
If you wish to specify the first and third opal servers in a set you specify:
e.g. datasources=opals.em[c(1,3)].}

\item{family}{This is a character string specifying the distribution of the observed
value of the outcome variable around the predictions generated by the linear predictor
as applied via the default or specified link function. Typical examples are
family = "binomial" for logistic regression models and family="poisson" for poisson
regression models. Note if you are fitting a gaussian model (a standard linear mixed
model you should use ds.lmerSLMA not ds.glmerSLMA. For further details about the
specification of family and link
functions in generalized linear models or generalized linear mixed models please
see R help for glm and glmer}

\item{control_type}{is an optional character string vector specifying the nature of a parameter
(or parameters) to be modified in the 'convergence control options' which can be viewed or
modified via the lme4::glmerControl function. At present only one such parameter can be modified,
namely the tolerance of the convergence criterion to the gradient of the log-likelihood 
at the maximum likelihood achieved. We have enabled this because our practical experience
suggests that in situations where the model looks to have converged with sensible parameter
values but formal convergence is not being declared, if we allow the model to be more
tolerant to a non-zero gradient the same parameter values are obtained but formal
convergence is declared. The default value for the check.conv.grad is 0.001 (note this
differs from the default of 0.002 for ds.lmerSLMA) but by specifying
control_type = "check.conv.grad" and specifying a specific value for the control_value
argument, you can change check.conv.grad to, for example, 0.01. If control_type is specified
as any character string other than "check.conv.grad" processing will stop and an error message
will be returned. If control_type is not specified or is declared as NULL, all control
parameters will take their default values (e.g. check.conv.grad will be set to 0.001).
If users need additional control parameters to be modified, the development team can enable
additional valid character strings to be specified for control_type. We have deliberately not
made it possible to modify any or all control parameters even though that would be relatively
easy. This is because it would require evaluating and then activating a potentially
complex text string on the serverside, which would potentially create a
hacking-in/disclosure risk.}

\item{control_value}{A numeric representing the new value which you want to allocate the
control parameter corresponding to the 'control-type'. At present (see control_type)
the only parameter this can be is the convergence tolerance "check.conv.grad". In
general, models will be identified as having converged more readily if the value set
for "check.conv.grad" is increased from its default (0.001) to,say, 0.01. Please note
that the risk of doing this is that the model is also more likely to be declared
as having converged at a local maximum that is not the global maximum likelihood.
This will not generally be a problem if the likelihood surface is well behaved but if
you have a problem with convergence you might usefully compare all the parameter
estimates and standard errors obtained using the default tolerance (0.001) even though
that has not formally converged with those obtained after convergence using the higher
tolerance. In our experience when the problem has simply been that a well behaved
model is simply failing to be declared as converged the two sets of parameters are
almost the same. If they are quite different you may have a badly behaved likelihood
surface and rather than simply allowing the model to converge by changing "check.conv.grad"
you probably ought to explore the likelihood surface in more detail - possibly by exploring
the impact of changing a range of the different control parameters via glmerControl (see
native R help for glmerControl). In the first instance you can potentially study this by
fitting the model on the data from a single study using lmer itself in native R.
If users need additional control parameters to be modified, the development team can enable
additional valid character strings to be specified for control_type. We have deliberately not
made it possible to modify any or all control parameters even though that would be relatively
easy. This is because it would require evaluating and then activating a potentially
complex text string on the serverside, which would potential create a
hacking-in/disclosure risk.}

\item{verbose}{integer scalar. If > 0 verbose output is generated during the optimization of
the parameter estimates. If > 1 verbose output is generated during the individual penalized 
iteratively reweighted least squares (PIRLS) steps. The output is contained in each studies'
summary in the "iterations" slot. Default value = 0, implying no additional output.}

\item{start_theta}{numeric vector of length equal to number of random effects. Specify to retain
more control over the optimisation. See glmer() for more details.}

\item{start_fixef}{numeric vector of length equal to number of fixed effects (NB including intercept). 
Specify to retain more control over the optimisation. See glmer() for more details.}

\item{notify.of.progress}{specifies if console output should be produce to indicate
progress. The default value for notify.of.progress is FALSE.}
}
\value{
\code{ds.glmerSLMA} returns a list of  elements mentioned 
below separaletly foreach study separately.

\code{coefficients}: a matrix with 5 columns:
   \itemize{
   \item{First}{: the names of all of the regression parameters (coefficients) in the model} 
   \item{second}{: the estimated values} 
   \item{third}{: corresponding standard errors of the stimated values} 
   \item{fourth}{: the ratio of estimate/standard error} 
   \item{fifth}{: the p-value treating that as a standardised normal deviate} 
}

\code{CorrMatrix}: the correlation matrix of parameter estimates.

\code{VarCovMatrix}: the variance covariance matrix of parameter estimates.

\code{weights}: the vector (if any) holding regression weights

\code{offset}: the vector (if any) holding an offset (enters glm with a coefficient of 1.0)

\code{cov.scaled}: equivalent to VarCovMatrix

\code{Nmissing}: the number of missing observations in the given study

\code{Nvalid}: the number of valid (non-missing) observations in the given study

\code{Ntotal}: the total number of observations in the given study (Nvalid+Nmissing)

\code{data}: equivalent to input parameter dataName (above)

code{call}: summary of key elements of the call to fit the model

Once the study-specific output has been returned, the function returns a
number of elements relating to the pooling of estimates across studies via
study level meta-analysis. These are as follows:

\code{input.beta.matrix.for.SLMA}: a matrix containing the vector of coefficient
estimates from each study. In combination with the corresponding standard errors
(see input.se.matrix.for.SLMA) these can be imported directly into a study level
meta-analysis (SLMA) package such as metafor to generate estimates pooled via SLMA

\code{input.se.matrix.for.SLMA}: a matrix containing the vector of standard error
estimates for coefficients from each study. In combination with the coefficients
(see input.beta.matrix.for.SLMA) these can be imported directly into a study level
meta-analysis (SLMA) package such as metafor to generate estimates pooled via SLMA

\code{SLMA.pooled.estimates}: a matrix containing pooled estimates for each
regression coefficient across all studies with pooling under SLMA via
random effects meta-analysis under maximum likelihood (ML), restricted maximum
likelihood (REML) or via fixed effects meta-analysis (FE)

\code{convergence.error.message}:  reports for each study whether the model converged.
If it did not some information about the reason for this is reported.
}
\description{
\code{ds.glmerSLMA} fits a generalized linear mixed effects model
(GLME) on data from one or multiple sources with pooling via SLMA (study level meta-analysis).
}
\details{
\code{ds.glmerSLMA} fits a generalized linear mixed effects model (GLME) 
- e.g. a logistic or Poisson regression model including both fixed and random effects -
 on data from a single or multiple sources. 
 
 This function is similar to \code{glmer} function from \code{lme4} package  in native R.
 
 When there are multiple data sources, the GLME is fitted to convergence 
 in each data source independently. The estimates and standard errors returned
 to the client-side which enable cross-study pooling  using study level meta-analysis (SLMA).
 The SLMA used by default \code{metafor} package  
 but as the SLMA occurs on the client-side (a standard R environment), the user can choose 
 any approach to meta-analysis. Additional information about fitting GLMES 
 using \code{glmer} function can be obtained using R help for \code{glmer} and the \code{lme4} package. 

Server function called: \code{glmerSLMADS2}
}
\author{
DataSHIELD Development Team
}
